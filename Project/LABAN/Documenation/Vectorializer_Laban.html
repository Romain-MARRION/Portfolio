<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Vectorializer_Laban API documentation</title>
<meta name="description" content="Created on Thu Apr
7 14:48:40 2022 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Vectorializer_Laban</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Apr
7 14:48:40 2022</p>
<p>@author: romai</p>
<p>This code allows to vectorize an AS according to Laban and returns a pandas dataframe.
Two ways to call the vectorizer with :</p>
<ul>
<li>
<p>VectorizerLaban: takes as input a pandas dataframe and outputs another dataframe from the vectorized AS</p>
</li>
<li>
<p>VectorizerLabanFromFilename: takes as input a path from the AS and returns another dataframe from the AS to vectorize</p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Apr  7 14:48:40 2022

@author: romai

This code allows to vectorize an AS according to Laban and returns a pandas dataframe.
Two ways to call the vectorizer with :

- VectorizerLaban: takes as input a pandas dataframe and outputs another dataframe from the vectorized AS

- VectorizerLabanFromFilename: takes as input a path from the AS and returns another dataframe from the AS to vectorize

&#34;&#34;&#34;


import pandas as pd
import numpy as np
from scipy.spatial import ConvexHull
import warnings
warnings.filterwarnings(&#34;ignore&#34;)

def createXYZJointVariables(dataframe):
    &#39;&#39;&#39;
    Create a global pandas.DataFrame variable named ~joint_name~Coordinates for each joint present in the dataframe passed as argument representing the x, y, z coordinates of the position of the jointure (as columns) at each instant (as rows).
   
    Parameters
    ----------
    dataframe : pandas.DataFrame
        Pandas dataframe that must have a &#34;joint_name&#34; column and x, y, z coordinates at columns indices 4:7 (the name of them hence does not matter).
    
    Returns
    -------
    None   
    &#39;&#39;&#39;
    
    for jointure in dataframe.joint_name.unique():
        globals()[str(jointure)] = dataframe.loc[dataframe[&#34;joint_name&#34;]==jointure].iloc[:,4:7].reset_index(drop=True)
        #create separate X Y Z dataframe variable for each jointure

def arrayCoordonateJointForATime(df,i):
    &#39;&#39;&#39;
    Create an array of the cartesien coordonate of the joint at a definite time

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the joint 
    jointName : String
        Joint&#39;s name which one we want the cartesien coordonate
    i : Integer
        Index of the sample

    Returns
    -------
    Array : numpy.array
        3D cartesien coordonate

    &#39;&#39;&#39;
    Array=np.array([df[&#39;x&#39;].iloc[i],df[&#39;y&#39;].iloc[i],df[&#39;z&#39;].iloc[i]])
    return Array

def angleBetweenTwoVectors(vecA,vecB):
    &#39;&#39;&#39;
    Compute the angle between two vectors, in degree

    Parameters
    ----------
    vecA : numpy.array
        First vector
    vecB : numpy.array
        Second vetcor

    Returns
    -------
    angle : Float
        The angle between the two vectors

    &#39;&#39;&#39;
    angle=np.degrees(np.arccos(np.dot(vecA,vecB)/(np.linalg.norm(vecA)*np.linalg.norm(vecB))))
    return angle

def QuickHullSeries(df):
    &#39;&#39;&#39;
    Compute the Quick hull for each frame 

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : TYPpandas.DataFrame
        Dataset of the Life moment we want to study

    Returns
    -------
    QuickHull : pandas.Series
        return a serie of the quick hull at each frame

    &#39;&#39;&#39;
    list_QuickHull=[]
    for i in range(0,len(df),25):
        list_QuickHull.append(ConvexHull(df[[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]].iloc[i:i+24]).volume)
    QuickHull=pd.Series(list_QuickHull)
    return QuickHull

def FlatteningSeries(df_joint_1,df_joint_2,df_joint_3,df_joint_4,df_joint_5):
    &#39;&#39;&#39;
    Compute the flattening of the life moment study.
    
    The flattening is defined in terms of major and minoraxis. 
    Here the major axis is the maximum between two distances,
    the first one is the distance between handsjoints (dhands) 
    and the second one is the distance between neck and shoulder center joints (dNeckShc).
    
    flattening = (max(dhands,dNeckSch)-min(dhands,dNeckSch)/max(dhands,dNeckSch)) 
    
    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study

    Returns
    -------
    Flattening : pandas.Series
        return a serie corresponding of the flattening of the Dataframe

    &#39;&#39;&#39;
    list_flattening=[]
    for i in range(len(df_joint_1)):
        distance_hand=np.linalg.norm(arrayCoordonateJointForATime(df_joint_1,i) \
                                     -arrayCoordonateJointForATime(df_joint_2,i))    
        distance_neck_shoulderCenter=np.linalg.norm((arrayCoordonateJointForATime(df_joint_3,i) \
                                              +arrayCoordonateJointForATime(df_joint_4,i))/2 \
                                              -arrayCoordonateJointForATime(df_joint_5,i))
        list_flattening.append((max([distance_hand,distance_neck_shoulderCenter] \
                            -min([distance_hand,distance_neck_shoulderCenter])) \
                            /max([distance_hand,distance_neck_shoulderCenter])))
    Flattening=pd.Series(list_flattening)
    return Flattening

def directionnalMovement(df):
    &#39;&#39;&#39;
    Compute the directionnalMovement of a joint 
    
    Directionnal movement is the summation of the angles, frormed by the position of a joint between 3 frames, over the time 

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName : String
        Joint&#39;s name which one we want the cartesien coordonate

    Returns
    -------
    DirectionalMovement : pandas.Series
        return a serie corresponding of the directionnal movement of a joint ofthe Dataframe

    &#39;&#39;&#39;
    list_directionnal_Movement=[]
    for i in range(1,len(df[&#39;x&#39;])-1):
        vecA=arrayCoordonateJointForATime(df,i-1)-arrayCoordonateJointForATime(df,i)
        vecB=arrayCoordonateJointForATime(df,i)-arrayCoordonateJointForATime(df,i+1)
        if i&gt;1: 
            list_directionnal_Movement.append(list_directionnal_Movement[-1]+angleBetweenTwoVectors(vecA,vecB))
        else: # trait the case of the first position
            list_directionnal_Movement.append(angleBetweenTwoVectors(vecA,vecB))
    DirectionalMovement=pd.Series(list_directionnal_Movement)
    return DirectionalMovement

def angleSeries(df_jointName1,df_jointName2,df_jointName3):
    &#39;&#39;&#39;
    return a serie corresponding to the angle between three joint over the time

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName1 : String
        First Joint&#39;s name 
    jointName2 : String
        Second Joint&#39;s name
    jointName3 : String
        Third Joint&#39;s name 

    Returns
    -------
    angle : pandas.Series
        series corresponding to the angle between three joint over the time

    &#39;&#39;&#39;
    list_angle=[]
    for i in range(1,len(df_jointName1)):
        vecA=arrayCoordonateJointForATime(df_jointName1,i)-arrayCoordonateJointForATime(df_jointName2,i)
        vecB=arrayCoordonateJointForATime(df_jointName2,i)-arrayCoordonateJointForATime(df_jointName3,i)
        list_angle.append(np.degrees(angleBetweenTwoVectors(vecA,vecB)))
    angle=pd.Series(list_angle)
    return angle

def distanceBetweenTwoJoints(df_jointName1,df_jointName2,axis=&#39;y&#39;):
    &#39;&#39;&#39;
    
    return the distance according one axis between two joints over the time 

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName1 : String
        First Joint&#39;s name 
    jointName2 : String
        Second Joint&#39;s name
    axis : String, optional
        axis according which one we want the distance. The default is &#39;y&#39;.

    Returns
    -------
    distance : pandas.Series
        Series corresponding to the distance between two joints

    &#39;&#39;&#39;
    distance=(df_jointName1[axis].reset_index(drop=True) - df_jointName2[axis].reset_index(drop=True))
    return distance

def carving(df,axis1,axis2):
    &#39;&#39;&#39;
    Return the carving of a joint according a map definite by two axis
    
    d = sqrt(sum((Pje-Pse)Â²)
    
    where P is the position feature, j represents each joint considered at each frame,sis the spine joint at initial frame andebelongs to oneof the following sets{x,y},{y,z}and{z,x}for each considered projection.

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName : String
        Joint&#39;s name which one we want the carving
    axis1 : String {&#39;x&#39;,&#39;y&#39; or &#39;z&#39;}
     first axis to definite the map
    axis2 : String {&#39;x&#39;,&#39;y&#39; or &#39;z&#39;}
        Second axis to definite the map

    Returns
    -------
    carving : pandas.Series
        Series corresponding to the carving of a joint according a map definite by two axis

    &#39;&#39;&#39;
    carving=((df[axis1].reset_index(drop=True)**2 + df[axis2].reset_index(drop=True)**2)**(1/2))
    return carving

def VectorizerLaban(ms,functions=[&#39;mean&#39;,&#39;std&#39;,&#39;min&#39;,&#39;max&#39;,&#39;median&#39;] ):
    &#39;&#39;&#39;
    return a dataframe which one conten the vector of the life moment we want to study

    Parameters
    ----------
    ms : pandas.DataFrame
        Dataset of the Life moment we want to study
    function : list of String, optional
        function that we want to apply on our differerent Series of features. The default is [&#39;mean&#39;,&#39;std&#39;,&#39;min&#39;,&#39;max&#39;,&#39;median&#39;].
    joints_carving : List of String, optional
        joint on which one we want to compute the carving. The default is [&#39;HandLeft&#39;,&#39;HandRight&#39;,&#39;FootLeft&#39;,&#39;FootRight&#39;,&#39;Head&#39;].

    Returns
    -------
    df_series : pandas.DataFrame
        dataFrame with the laban&#39;s vector.

    &#39;&#39;&#39;
    createXYZJointVariables(ms)
    joints_carving=[&#39;HandLeft&#39;,&#39;HandRight&#39;,&#39;FootLeft&#39;,&#39;FootRight&#39;,&#39;Head&#39;]
    QuickHull=QuickHullSeries(ms)
    angle_up_left=angleSeries(globals() [&#39;WristLeft&#39;],globals()[&#39;ElbowLeft&#39;],globals()[&#39;ShoulderLeft&#39;])
    angle_up_Right=angleSeries(globals() [&#39;WristRight&#39;],globals() [&#39;ElbowRight&#39;],globals() [&#39;ShoulderRight&#39;])
    angle_down_left=angleSeries(globals() [&#39;HipLeft&#39;],globals() [&#39;KneeLeft&#39;],globals() [&#39;FootLeft&#39;])
    angle_down_Right=angleSeries(globals() [&#39;HipRight&#39;],globals() [&#39;KneeRight&#39;],globals() [&#39;FootRight&#39;])
    flattening=FlatteningSeries(df_joint_1=globals() [&#39;HandLeft&#39;],df_joint_2=globals() [&#39;HandRight&#39;],df_joint_3=globals() [&#39;ShoulderLeft&#39;],df_joint_4=globals() [&#39;ShoulderRight&#39;],df_joint_5=globals() [&#39;Neck&#39;])
    dm_hand_left=directionnalMovement(globals() [&#39;HandLeft&#39;])
    dm_hand_right=directionnalMovement(globals() [&#39;HandRight&#39;])
    
    df_series=pd.DataFrame(index=[&#39;0&#39;])
    
    
    
    for function in functions:
        df_series[f&#39;{function}_distance_hip_FootLeft&#39;]=distanceBetweenTwoJoints(globals() [&#39;HipLeft&#39;],globals() [&#39;FootLeft&#39;]).agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_distance_hip_FootRight&#39;]=distanceBetweenTwoJoints(globals() [&#39;HipRight&#39;],globals() [&#39;FootRight&#39;]).agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_dm_hand_left&#39;]=dm_hand_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_dm_hand_right&#39;]=dm_hand_right.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_QuickHull&#39;]=QuickHull.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_flattening&#39;]=flattening.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_up_left&#39;]=angle_up_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_up_Right&#39;]=angle_up_Right.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_down_left&#39;]=angle_down_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_down_Right&#39;]=angle_down_Right.agg([f&#39;{function}&#39;])[0]
        
        for joint_name in joints_carving:
            df_series[f&#39;{function}_carving_{joint_name}_XY&#39;]=carving(globals()[joint_name],&#39;x&#39;,&#39;y&#39;).agg([f&#39;{function}&#39;])[0]
            df_series[f&#39;{function}_carving_{joint_name}_XZ&#39;]=carving(globals()[joint_name],&#39;x&#39;,&#39;z&#39;).agg([f&#39;{function}&#39;])[0]
            df_series[f&#39;{function}_carving_{joint_name}_ZY&#39;]=carving(globals()[joint_name],&#39;z&#39;,&#39;y&#39;).agg([f&#39;{function}&#39;])[0]
            
    return df_series

def VectorizerLabanFromFilename(filename):

    &#39;&#39;&#39;
    return a dataframe which one contain the vector of the life moment we want to study

    Parameters
    ----------
    filename : String
        name of the csv file
    Returns
    -------
    df: pandas.DataFrame
        dataFrame with the laban&#39;s vector.

    &#39;&#39;&#39;

    ms=pd.read_csv(filename, names=[&#34;id_Camera&#34;, &#34;date&#34;, &#34;index&#34;, &#34;id_individual&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;joint_name&#34;, &#34;track_accuracy&#34;])

    df= VectorizerLaban(ms=ms)
    return df

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Vectorializer_Laban.FlatteningSeries"><code class="name flex">
<span>def <span class="ident">FlatteningSeries</span></span>(<span>df_joint_1, df_joint_2, df_joint_3, df_joint_4, df_joint_5)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the flattening of the life moment study.</p>
<p>The flattening is defined in terms of major and minoraxis.
Here the major axis is the maximum between two distances,
the first one is the distance between handsjoints (dhands)
and the second one is the distance between neck and shoulder center joints (dNeckShc).</p>
<p>flattening = (max(dhands,dNeckSch)-min(dhands,dNeckSch)/max(dhands,dNeckSch)) </p>
<p>(see "Robust human action recognition system using Laban Movement Analysis" by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Flattening</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>return a serie corresponding of the flattening of the Dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FlatteningSeries(df_joint_1,df_joint_2,df_joint_3,df_joint_4,df_joint_5):
    &#39;&#39;&#39;
    Compute the flattening of the life moment study.
    
    The flattening is defined in terms of major and minoraxis. 
    Here the major axis is the maximum between two distances,
    the first one is the distance between handsjoints (dhands) 
    and the second one is the distance between neck and shoulder center joints (dNeckShc).
    
    flattening = (max(dhands,dNeckSch)-min(dhands,dNeckSch)/max(dhands,dNeckSch)) 
    
    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study

    Returns
    -------
    Flattening : pandas.Series
        return a serie corresponding of the flattening of the Dataframe

    &#39;&#39;&#39;
    list_flattening=[]
    for i in range(len(df_joint_1)):
        distance_hand=np.linalg.norm(arrayCoordonateJointForATime(df_joint_1,i) \
                                     -arrayCoordonateJointForATime(df_joint_2,i))    
        distance_neck_shoulderCenter=np.linalg.norm((arrayCoordonateJointForATime(df_joint_3,i) \
                                              +arrayCoordonateJointForATime(df_joint_4,i))/2 \
                                              -arrayCoordonateJointForATime(df_joint_5,i))
        list_flattening.append((max([distance_hand,distance_neck_shoulderCenter] \
                            -min([distance_hand,distance_neck_shoulderCenter])) \
                            /max([distance_hand,distance_neck_shoulderCenter])))
    Flattening=pd.Series(list_flattening)
    return Flattening</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.QuickHullSeries"><code class="name flex">
<span>def <span class="ident">QuickHullSeries</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Quick hull for each frame </p>
<p>(see "Robust human action recognition system using Laban Movement Analysis" by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>TYPpandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>QuickHull</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>return a serie of the quick hull at each frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def QuickHullSeries(df):
    &#39;&#39;&#39;
    Compute the Quick hull for each frame 

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : TYPpandas.DataFrame
        Dataset of the Life moment we want to study

    Returns
    -------
    QuickHull : pandas.Series
        return a serie of the quick hull at each frame

    &#39;&#39;&#39;
    list_QuickHull=[]
    for i in range(0,len(df),25):
        list_QuickHull.append(ConvexHull(df[[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]].iloc[i:i+24]).volume)
    QuickHull=pd.Series(list_QuickHull)
    return QuickHull</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.VectorizerLaban"><code class="name flex">
<span>def <span class="ident">VectorizerLaban</span></span>(<span>ms, functions=['mean', 'std', 'min', 'max', 'median'])</span>
</code></dt>
<dd>
<div class="desc"><p>return a dataframe which one conten the vector of the life moment we want to study</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ms</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
<dt><strong><code>function</code></strong> :&ensp;<code>list</code> of <code>String</code>, optional</dt>
<dd>function that we want to apply on our differerent Series of features. The default is ['mean','std','min','max','median'].</dd>
<dt><strong><code>joints_carving</code></strong> :&ensp;<code>List</code> of <code>String</code>, optional</dt>
<dd>joint on which one we want to compute the carving. The default is ['HandLeft','HandRight','FootLeft','FootRight','Head'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_series</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>dataFrame with the laban's vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VectorizerLaban(ms,functions=[&#39;mean&#39;,&#39;std&#39;,&#39;min&#39;,&#39;max&#39;,&#39;median&#39;] ):
    &#39;&#39;&#39;
    return a dataframe which one conten the vector of the life moment we want to study

    Parameters
    ----------
    ms : pandas.DataFrame
        Dataset of the Life moment we want to study
    function : list of String, optional
        function that we want to apply on our differerent Series of features. The default is [&#39;mean&#39;,&#39;std&#39;,&#39;min&#39;,&#39;max&#39;,&#39;median&#39;].
    joints_carving : List of String, optional
        joint on which one we want to compute the carving. The default is [&#39;HandLeft&#39;,&#39;HandRight&#39;,&#39;FootLeft&#39;,&#39;FootRight&#39;,&#39;Head&#39;].

    Returns
    -------
    df_series : pandas.DataFrame
        dataFrame with the laban&#39;s vector.

    &#39;&#39;&#39;
    createXYZJointVariables(ms)
    joints_carving=[&#39;HandLeft&#39;,&#39;HandRight&#39;,&#39;FootLeft&#39;,&#39;FootRight&#39;,&#39;Head&#39;]
    QuickHull=QuickHullSeries(ms)
    angle_up_left=angleSeries(globals() [&#39;WristLeft&#39;],globals()[&#39;ElbowLeft&#39;],globals()[&#39;ShoulderLeft&#39;])
    angle_up_Right=angleSeries(globals() [&#39;WristRight&#39;],globals() [&#39;ElbowRight&#39;],globals() [&#39;ShoulderRight&#39;])
    angle_down_left=angleSeries(globals() [&#39;HipLeft&#39;],globals() [&#39;KneeLeft&#39;],globals() [&#39;FootLeft&#39;])
    angle_down_Right=angleSeries(globals() [&#39;HipRight&#39;],globals() [&#39;KneeRight&#39;],globals() [&#39;FootRight&#39;])
    flattening=FlatteningSeries(df_joint_1=globals() [&#39;HandLeft&#39;],df_joint_2=globals() [&#39;HandRight&#39;],df_joint_3=globals() [&#39;ShoulderLeft&#39;],df_joint_4=globals() [&#39;ShoulderRight&#39;],df_joint_5=globals() [&#39;Neck&#39;])
    dm_hand_left=directionnalMovement(globals() [&#39;HandLeft&#39;])
    dm_hand_right=directionnalMovement(globals() [&#39;HandRight&#39;])
    
    df_series=pd.DataFrame(index=[&#39;0&#39;])
    
    
    
    for function in functions:
        df_series[f&#39;{function}_distance_hip_FootLeft&#39;]=distanceBetweenTwoJoints(globals() [&#39;HipLeft&#39;],globals() [&#39;FootLeft&#39;]).agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_distance_hip_FootRight&#39;]=distanceBetweenTwoJoints(globals() [&#39;HipRight&#39;],globals() [&#39;FootRight&#39;]).agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_dm_hand_left&#39;]=dm_hand_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_dm_hand_right&#39;]=dm_hand_right.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_QuickHull&#39;]=QuickHull.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_flattening&#39;]=flattening.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_up_left&#39;]=angle_up_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_up_Right&#39;]=angle_up_Right.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_down_left&#39;]=angle_down_left.agg([f&#39;{function}&#39;])[0]
        df_series[f&#39;{function}_angle_down_Right&#39;]=angle_down_Right.agg([f&#39;{function}&#39;])[0]
        
        for joint_name in joints_carving:
            df_series[f&#39;{function}_carving_{joint_name}_XY&#39;]=carving(globals()[joint_name],&#39;x&#39;,&#39;y&#39;).agg([f&#39;{function}&#39;])[0]
            df_series[f&#39;{function}_carving_{joint_name}_XZ&#39;]=carving(globals()[joint_name],&#39;x&#39;,&#39;z&#39;).agg([f&#39;{function}&#39;])[0]
            df_series[f&#39;{function}_carving_{joint_name}_ZY&#39;]=carving(globals()[joint_name],&#39;z&#39;,&#39;y&#39;).agg([f&#39;{function}&#39;])[0]
            
    return df_series</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.VectorizerLabanFromFilename"><code class="name flex">
<span>def <span class="ident">VectorizerLabanFromFilename</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>return a dataframe which one contain the vector of the life moment we want to study</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>String</code></dt>
<dd>name of the csv file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>dataFrame with the laban's vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VectorizerLabanFromFilename(filename):

    &#39;&#39;&#39;
    return a dataframe which one contain the vector of the life moment we want to study

    Parameters
    ----------
    filename : String
        name of the csv file
    Returns
    -------
    df: pandas.DataFrame
        dataFrame with the laban&#39;s vector.

    &#39;&#39;&#39;

    ms=pd.read_csv(filename, names=[&#34;id_Camera&#34;, &#34;date&#34;, &#34;index&#34;, &#34;id_individual&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;joint_name&#34;, &#34;track_accuracy&#34;])

    df= VectorizerLaban(ms=ms)
    return df</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.angleBetweenTwoVectors"><code class="name flex">
<span>def <span class="ident">angleBetweenTwoVectors</span></span>(<span>vecA, vecB)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle between two vectors, in degree</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vecA</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>First vector</dd>
<dt><strong><code>vecB</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Second vetcor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>Float</code></dt>
<dd>The angle between the two vectors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angleBetweenTwoVectors(vecA,vecB):
    &#39;&#39;&#39;
    Compute the angle between two vectors, in degree

    Parameters
    ----------
    vecA : numpy.array
        First vector
    vecB : numpy.array
        Second vetcor

    Returns
    -------
    angle : Float
        The angle between the two vectors

    &#39;&#39;&#39;
    angle=np.degrees(np.arccos(np.dot(vecA,vecB)/(np.linalg.norm(vecA)*np.linalg.norm(vecB))))
    return angle</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.angleSeries"><code class="name flex">
<span>def <span class="ident">angleSeries</span></span>(<span>df_jointName1, df_jointName2, df_jointName3)</span>
</code></dt>
<dd>
<div class="desc"><p>return a serie corresponding to the angle between three joint over the time</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
<dt><strong><code>jointName1</code></strong> :&ensp;<code>String</code></dt>
<dd>First Joint's name</dd>
<dt><strong><code>jointName2</code></strong> :&ensp;<code>String</code></dt>
<dd>Second Joint's name</dd>
<dt><strong><code>jointName3</code></strong> :&ensp;<code>String</code></dt>
<dd>Third Joint's name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>series corresponding to the angle between three joint over the time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angleSeries(df_jointName1,df_jointName2,df_jointName3):
    &#39;&#39;&#39;
    return a serie corresponding to the angle between three joint over the time

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName1 : String
        First Joint&#39;s name 
    jointName2 : String
        Second Joint&#39;s name
    jointName3 : String
        Third Joint&#39;s name 

    Returns
    -------
    angle : pandas.Series
        series corresponding to the angle between three joint over the time

    &#39;&#39;&#39;
    list_angle=[]
    for i in range(1,len(df_jointName1)):
        vecA=arrayCoordonateJointForATime(df_jointName1,i)-arrayCoordonateJointForATime(df_jointName2,i)
        vecB=arrayCoordonateJointForATime(df_jointName2,i)-arrayCoordonateJointForATime(df_jointName3,i)
        list_angle.append(np.degrees(angleBetweenTwoVectors(vecA,vecB)))
    angle=pd.Series(list_angle)
    return angle</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.arrayCoordonateJointForATime"><code class="name flex">
<span>def <span class="ident">arrayCoordonateJointForATime</span></span>(<span>df, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an array of the cartesien coordonate of the joint at a definite time</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the joint</dd>
<dt><strong><code>jointName</code></strong> :&ensp;<code>String</code></dt>
<dd>Joint's name which one we want the cartesien coordonate</dd>
<dt><strong><code>i</code></strong> :&ensp;<code>Integer</code></dt>
<dd>Index of the sample</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Array</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>3D cartesien coordonate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrayCoordonateJointForATime(df,i):
    &#39;&#39;&#39;
    Create an array of the cartesien coordonate of the joint at a definite time

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the joint 
    jointName : String
        Joint&#39;s name which one we want the cartesien coordonate
    i : Integer
        Index of the sample

    Returns
    -------
    Array : numpy.array
        3D cartesien coordonate

    &#39;&#39;&#39;
    Array=np.array([df[&#39;x&#39;].iloc[i],df[&#39;y&#39;].iloc[i],df[&#39;z&#39;].iloc[i]])
    return Array</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.carving"><code class="name flex">
<span>def <span class="ident">carving</span></span>(<span>df, axis1, axis2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the carving of a joint according a map definite by two axis</p>
<p>d = sqrt(sum((Pje-Pse)Â²)</p>
<p>where P is the position feature, j represents each joint considered at each frame,sis the spine joint at initial frame andebelongs to oneof the following sets{x,y},{y,z}and{z,x}for each considered projection.</p>
<p>(see "Robust human action recognition system using Laban Movement Analysis" by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
<dt><strong><code>jointName</code></strong> :&ensp;<code>String</code></dt>
<dd>Joint's name which one we want the carving</dd>
<dt><strong><code>axis1</code></strong> :&ensp;<code>String {'x','y'</code> or <code>'z'}</code></dt>
<dd>&nbsp;</dd>
<dt>first axis to definite the map</dt>
<dt><strong><code>axis2</code></strong> :&ensp;<code>String {'x','y'</code> or <code>'z'}</code></dt>
<dd>Second axis to definite the map</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>carving</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>Series corresponding to the carving of a joint according a map definite by two axis</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def carving(df,axis1,axis2):
    &#39;&#39;&#39;
    Return the carving of a joint according a map definite by two axis
    
    d = sqrt(sum((Pje-Pse)Â²)
    
    where P is the position feature, j represents each joint considered at each frame,sis the spine joint at initial frame andebelongs to oneof the following sets{x,y},{y,z}and{z,x}for each considered projection.

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName : String
        Joint&#39;s name which one we want the carving
    axis1 : String {&#39;x&#39;,&#39;y&#39; or &#39;z&#39;}
     first axis to definite the map
    axis2 : String {&#39;x&#39;,&#39;y&#39; or &#39;z&#39;}
        Second axis to definite the map

    Returns
    -------
    carving : pandas.Series
        Series corresponding to the carving of a joint according a map definite by two axis

    &#39;&#39;&#39;
    carving=((df[axis1].reset_index(drop=True)**2 + df[axis2].reset_index(drop=True)**2)**(1/2))
    return carving</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.createXYZJointVariables"><code class="name flex">
<span>def <span class="ident">createXYZJointVariables</span></span>(<span>dataframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a global pandas.DataFrame variable named ~joint_name~Coordinates for each joint present in the dataframe passed as argument representing the x, y, z coordinates of the position of the jointure (as columns) at each instant (as rows).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Pandas dataframe that must have a "joint_name" column and x, y, z coordinates at columns indices 4:7 (the name of them hence does not matter).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createXYZJointVariables(dataframe):
    &#39;&#39;&#39;
    Create a global pandas.DataFrame variable named ~joint_name~Coordinates for each joint present in the dataframe passed as argument representing the x, y, z coordinates of the position of the jointure (as columns) at each instant (as rows).
   
    Parameters
    ----------
    dataframe : pandas.DataFrame
        Pandas dataframe that must have a &#34;joint_name&#34; column and x, y, z coordinates at columns indices 4:7 (the name of them hence does not matter).
    
    Returns
    -------
    None   
    &#39;&#39;&#39;
    
    for jointure in dataframe.joint_name.unique():
        globals()[str(jointure)] = dataframe.loc[dataframe[&#34;joint_name&#34;]==jointure].iloc[:,4:7].reset_index(drop=True)
        #create separate X Y Z dataframe variable for each jointure</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.directionnalMovement"><code class="name flex">
<span>def <span class="ident">directionnalMovement</span></span>(<span>df)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the directionnalMovement of a joint </p>
<p>Directionnal movement is the summation of the angles, frormed by the position of a joint between 3 frames, over the time </p>
<p>(see "Robust human action recognition system using Laban Movement Analysis" by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
<dt><strong><code>jointName</code></strong> :&ensp;<code>String</code></dt>
<dd>Joint's name which one we want the cartesien coordonate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DirectionalMovement</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>return a serie corresponding of the directionnal movement of a joint ofthe Dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def directionnalMovement(df):
    &#39;&#39;&#39;
    Compute the directionnalMovement of a joint 
    
    Directionnal movement is the summation of the angles, frormed by the position of a joint between 3 frames, over the time 

    (see &#34;Robust human action recognition system using Laban Movement Analysis&#34; by InsafAjili*,MalikMallem,Jean-YvesDidier,2017 )

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName : String
        Joint&#39;s name which one we want the cartesien coordonate

    Returns
    -------
    DirectionalMovement : pandas.Series
        return a serie corresponding of the directionnal movement of a joint ofthe Dataframe

    &#39;&#39;&#39;
    list_directionnal_Movement=[]
    for i in range(1,len(df[&#39;x&#39;])-1):
        vecA=arrayCoordonateJointForATime(df,i-1)-arrayCoordonateJointForATime(df,i)
        vecB=arrayCoordonateJointForATime(df,i)-arrayCoordonateJointForATime(df,i+1)
        if i&gt;1: 
            list_directionnal_Movement.append(list_directionnal_Movement[-1]+angleBetweenTwoVectors(vecA,vecB))
        else: # trait the case of the first position
            list_directionnal_Movement.append(angleBetweenTwoVectors(vecA,vecB))
    DirectionalMovement=pd.Series(list_directionnal_Movement)
    return DirectionalMovement</code></pre>
</details>
</dd>
<dt id="Vectorializer_Laban.distanceBetweenTwoJoints"><code class="name flex">
<span>def <span class="ident">distanceBetweenTwoJoints</span></span>(<span>df_jointName1, df_jointName2, axis='y')</span>
</code></dt>
<dd>
<div class="desc"><p>return the distance according one axis between two joints over the time </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataset of the Life moment we want to study</dd>
<dt><strong><code>jointName1</code></strong> :&ensp;<code>String</code></dt>
<dd>First Joint's name</dd>
<dt><strong><code>jointName2</code></strong> :&ensp;<code>String</code></dt>
<dd>Second Joint's name</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>String</code>, optional</dt>
<dd>axis according which one we want the distance. The default is 'y'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>distance</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>Series corresponding to the distance between two joints</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distanceBetweenTwoJoints(df_jointName1,df_jointName2,axis=&#39;y&#39;):
    &#39;&#39;&#39;
    
    return the distance according one axis between two joints over the time 

    Parameters
    ----------
    df : pandas.DataFrame
        Dataset of the Life moment we want to study
    jointName1 : String
        First Joint&#39;s name 
    jointName2 : String
        Second Joint&#39;s name
    axis : String, optional
        axis according which one we want the distance. The default is &#39;y&#39;.

    Returns
    -------
    distance : pandas.Series
        Series corresponding to the distance between two joints

    &#39;&#39;&#39;
    distance=(df_jointName1[axis].reset_index(drop=True) - df_jointName2[axis].reset_index(drop=True))
    return distance</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Vectorializer_Laban.FlatteningSeries" href="#Vectorializer_Laban.FlatteningSeries">FlatteningSeries</a></code></li>
<li><code><a title="Vectorializer_Laban.QuickHullSeries" href="#Vectorializer_Laban.QuickHullSeries">QuickHullSeries</a></code></li>
<li><code><a title="Vectorializer_Laban.VectorizerLaban" href="#Vectorializer_Laban.VectorizerLaban">VectorizerLaban</a></code></li>
<li><code><a title="Vectorializer_Laban.VectorizerLabanFromFilename" href="#Vectorializer_Laban.VectorizerLabanFromFilename">VectorizerLabanFromFilename</a></code></li>
<li><code><a title="Vectorializer_Laban.angleBetweenTwoVectors" href="#Vectorializer_Laban.angleBetweenTwoVectors">angleBetweenTwoVectors</a></code></li>
<li><code><a title="Vectorializer_Laban.angleSeries" href="#Vectorializer_Laban.angleSeries">angleSeries</a></code></li>
<li><code><a title="Vectorializer_Laban.arrayCoordonateJointForATime" href="#Vectorializer_Laban.arrayCoordonateJointForATime">arrayCoordonateJointForATime</a></code></li>
<li><code><a title="Vectorializer_Laban.carving" href="#Vectorializer_Laban.carving">carving</a></code></li>
<li><code><a title="Vectorializer_Laban.createXYZJointVariables" href="#Vectorializer_Laban.createXYZJointVariables">createXYZJointVariables</a></code></li>
<li><code><a title="Vectorializer_Laban.directionnalMovement" href="#Vectorializer_Laban.directionnalMovement">directionnalMovement</a></code></li>
<li><code><a title="Vectorializer_Laban.distanceBetweenTwoJoints" href="#Vectorializer_Laban.distanceBetweenTwoJoints">distanceBetweenTwoJoints</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>